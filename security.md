security tips

- https://tproger.ru/translations/webapp-security/
- https://habr.com/ru/company/mailru/blog/310726/
- https://github.com/Roave/SecurityAdvisories

### HTTPS

HyperText Transfer Protocol Secure (HTTPS) — расширение HTTP, которое поддерживает шифрование и защищает данные пользователей при передаче в Интернете.
- гарантирует целостность и конфиденциальность взаимодействия с сервером
- снижает вероятность кражи куки пользователей и последующей подделки запроса
- ssl-сертификат генерируется бесплатно (с возможностью автоматического получения и их установки)
- хорошая практика - юзать HTTP Strict Transport Security (HSTS) — заголовка ответа сервера, который запрещает для домена использование незащищённого соединения.

### Регулярные обновления ПО
Сюда входит:
- обновление ОС на серверах
- обновление фреймворков и зависимых компонентов (через Composer, NPM...)

Как правило, разработчики ПО при выходе новых версий делают рассылки с рекомендациями необходимости обновлений для
устранения критических уязвимостей.
Для Composer есть пакет:
- https://github.com/Roave/SecurityAdvisories
В нем сообществом собираются известные уязвимые версии пакетов

### Всегда проверять входные данные

Контролируйте данные, полученные с веб-форм, как на стороне клиента, так и на стороне сервера. 
В браузере проверяются простые ошибки вроде незаполненного обязательного поля или текста, введённого в числовое поле. 
Эти проверки обходятся, поэтому контроль на стороне сервера обязателен. Отсутствие проверки на стороне сервера приводит к
 эксплуатации злоумышленником инъекций и других видов атак.

### SQL injection

SQL-инъекция - выполнение произвольного SQL
 запроса к базе данных приложения с помощью манипуляций параметров запроса (поля формы или параметра URL)

Это приводит к возможности вставить вредоносный код в тело запроса:
- Утечки данных.
- Раскрытие хранимой информации.
- Манипулирование хранимой информацией.
- Обход авторизации.
- Внедрение SQL на стороне клиента.

все данные, которые не были явным образом созданы в исходном PHP-коде текущего запроса, ненадёжны. Строго проверяйте их и отклоняйте всё, 
что не прошло проверок. Не пытайтесь «исправить» данные, можно внести лишь лёгкие, косметические изменения в формат.

- экранирование (лучше след вариант. К этому в крайнем случае, если библиотека БД. mysqli_real_escape_string )
- параметризированные запросы (PHP и MySQLi)
    
    
    $stmt = $pdo->prepare('SELECT * FROM table WHERE column = :value');
    $stmt->execute(array('value' => $parameter));
    //$stmt->bindParam(':id', $validatedId, PDO::PARAM_INT);
    //$stmt->execute();    
    

### XSS (cross site scripting)
(XSS) — тип атаки на веб-ресурсы, заключающийся во внедрении в страницу сайта вредоносного кода, который 
- выполняется на компьютере пользователя (пример, вредоносный JavaScript)
- изменяет страницу
- передает украденную информацию на сервера злоумышленника (данные об авторизации из cookies-файлов)

Решение
- фильтрация входных данных (использование белых списков, вырезаение запрещенных элементов и т.п.) 
- при формировании контекнта (html
 странички) экранировать (encode) всех данных, принятых от пользователя:
    - на php-шаблонизаторе юзать htmlspecialchars для вывода данных (либо обертки, предоставляемые фреймворком)
    - на сторонних шаблонизаторах (twig ..), юзать встроенные средства экранизации специальных символов

### CSRF (cross site request forgery)
межсайтовая подделка запросов

- https://habr.com/ru/post/134150/ (пост про csrf у хабра)

Причина CSRF кроется в том, что браузеры не понимают, как различить, было ли действие явно совершено пользователем (как, скажем, нажатие кнопки на форме 
или переход по ссылке) или пользователь неумышленно выполнил это действие (например, при посещении bad.com, ресурсом был отправлен запрос на good.com/some_action,
 в то время как пользователь уже был залогинен на good.com).

Решение:
 - csrf токен. Под токеном имеется в виду случайный набор байт, который сервер передает клиенту, а клиент возвращает серверу.
 
 
![рис](https://skr.sh/s325K6Ky9y1?a)

- При старте сессии на стороне сервера генерируется токен.
- Токен кладется в хранилище данных сессии (т.е. сохраняется на стороне сервера для последующей проверки)
- В ответ на запрос (который стартовал сессию) клиенту возвращается токен.

Если рендеринг происходит на сервере, то токен может возвращаться внутри HTML, как, например, одно из полей формы, или внутри <meta> тега.

В случае, если ответ возвращается для JS приложения, токен можно передавать в header (часто для этого используют X-CSRF-Token)

- При последующих запросах клиент обязан передать токен серверу для проверки.


При рендере контента сервером токен принято возвращать внутри POST данных формы.


JS приложения обычно присылают XHR (XMLHttpRequest) запросы с header (X-CSRF-Token), содержащим токен.


- При получения запроса небезопасным методом (POST, PUT, DELETE, PATCH
) сервер обязан проверить на идентичность токен из данных сессии и токен, который прислал клиент.


Если оба токена совпадают, то запрос не подвергся CSRF-Атаке, в ином случае — логируем событие и отклоняем запрос.
 
Защита сводится к проверке токена, который сгенерировал сервер, и токена, который прислал пользователь. (как правило, поддерживается из коробки фреймворков)

- защищать только небезопасные методы: POST, PUT, DELETE, PATCH (в соотвествии со стандартом RFC7231, то методы GET, HEAD, OPTIONS и TRACE являются безопасными:
они предназначены только для получения информации и не должны изменять состояние сервера.)


3 вида (https://habr.com/ru/post/318748/)
- Synchronizer Tokens (Statefull) - описан выше
- Double Submit Cookie (Stateless) - (https://stackoverflow.com/questions/11518245/csrf-attacks-and-double-submitted
-cookie/29622103#29622103 хорошо описано)
- Encrypted Token (Stateless)

Реализация:
- помним про SOP (нужно правильно настраивать CORS для межсайтового взаимодействия)
- генерировать новый токен на каждый запрос, не важно, каким HTTP-методом и с какой целью этот запрос сделан.
Таким образом мы получаем токен, который меняется постоянно.
- Ограничиваем время жизни cookie, которое содержит токен, разумным значением. Например 30 минут.
- Делаем cookie недоступной из JS (ставим HTTPOnly=true)
- Используем TLS для предотвращения MITM. При этом отправляем cookie только по HTTPS (ставим Secure=true)
- Размер токена не менее 32 байт.
- Генерируем токен криптографически стойким генератором псевдослучайных чисел.
Для этого можно использовать системные функции:

    Linux => getrandom(2) если возможно, /dev/urandom иначе
    OpenBSD => getentropy(2)
    На других Unix-like системах => /dev/urandom
    Windows => CryptGenRandom API

### Шифрование паролей


### Детальные сообщения об ошибках

Будьте осторожны с тем, что отображается в сообщениях об ошибках приложения. Сообщайте пользователю информацию об ошибках в максимально лаконичной форме,
 которая исключает наличие любой технической информации. Подробные сведения храните в лог-файлах сервера. Ведь имея полную информацию
 , злоумышленнику проще произвести комплексные атаки вроде SQL-инъекции.

Чтобы держать руку на пульсе проекта, установите систему мониторинга ошибок.

### Распределяйте права доступа к файлам

Разрешения файла (file permissions) определяют КТО и ЧТО может с ним делать.

В *nix системах у файлов 3 варианта доступа, которые представляются в виде цифр:

- «Read» (4) — чтение содержимого файла;
- «Write» (2) — изменение содержимого файла;
- «Execute» (1) — выполнение программы или скрипта.
Чтобы установить множественные разрешения, достаточно сложить их числовые значения:

- «Чтение» (4) + «запись» (2) = 6;
- «Чтение» (4) + «запись» (2) + «выполнение» (1) = 7.
При распределении прав пользователи делятся на 3 типа:

- «Owner» (владелец) — создатель файла (изменяем, но может быть только один);
- «Group» (группа) — группа пользователей, которые получают разрешения;
- «Others» (прочие) — остальные пользователи.

Установка владельцу прав доступа на чтение и запись, группе — на чтение, прочим — запрет доступа выглядит так:

Итоговое представление: 640.

Для каталогов аналогично, но флаг «выполнить» значит сделать рабочей директорией.

При установке CMS-разрешения, как правило, устанавливаются корректно с точки зрения безопасности.
 Однако в Интернете часто советуют решать проблемы прав доступа установкой на все файлы значения 666 или 777. 
 Этот совет помогает решить проблему, но открывает серьёзную уязвимость, потому что всем появляется право изменить (вставить вредоносный код) или 
 удалить файлы на сервере. Распределяйте права доступа к файлам на сервере в соответствии с задачами пользователей.
 
### Контролировать процесс загрузки файлов на сервер
Обычная загрузка файла с картинкой может содержать скрипт, который при выполнении на сервере может открыть доступ к сайту

- ограничения на тип не решают проблему (mime-тайп легко подменить)
- чтение заголовков и функции проверки размера изображений также не дают 100% гарантии

Решение: запретить исполнение загружаемых файлов пользователями. Способы ограничения доступа:
- переименовывать или изменять расширения файлов при загрузке;
- изменять разрешения, например, на chmod 0666;
- создать файл .htaccess (см. пример ниже), который откроет доступ только к указанным типам файлов.
- запретить прямой доступ к загружаемым файлам, разместив их, например, вне папки корня сайта

Меры защиты веб-приложений для собственных серверов:
- Настройте межсетевой экран, в том числе на блокировку неиспользуемых портов.
- При наличии доступа к серверу из локальной сети создайте демилитаризованную зону (DMZ
), открыв доступ из внешнего мира только к портам 80 и 443.
- При отсутствии доступа к серверу из локальной сети используйте защищённые методы (SFTP, SSH
 и др.) для передачи файлов и управления сервером извне.
- Если возможно, выделите отдельный сервер для баз данных, который не будет напрямую доступен из внешнего мира.
- Отграничьте физический доступ к серверу.

### CORS

- https://developer.mozilla.org/ru/docs/Web/HTTP/CORS
- https://developer.mozilla.org/ru/docs/Web/Security/Same-origin_policy

Cross-Origin Resource Sharing (CORS) — механизм, использующий дополнительные HTTP-заголовки, чтобы дать возможность агенту пользователя 
получать разрешения на доступ к выбранным ресурсам с сервера на источнике (домене), отличном от того, что сайт использует в данный момент. 
Говорят, что агент пользователя делает запрос с другого источника (cross-origin HTTP request), если источник текущего документа отличается о
т запрашиваемого ресурса доменом, протоколом или портом.

Если Same-Origin-Policy (SOP) настроен не правильно, на пример "Access-Control-Allow-Origin: *" то любая CSRF защита будет в пустую. 
По-умолчанию  только Same-Origin, так что если вы не настраиваете хедер в ручную, проблем у вас не должно быть.
