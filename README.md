
Useful packages, links and materials

- [PHP](#php)
    + [Articles](#articles)
    + [Packages](#packages)
      - [For require-dev](#for-require-dev)
      - [Static analysis tools](#static-analysis-tools)
      - [Profiling tools](#profiling-tools)
      - [PSR](#psr)
      - [Template engines etc](#template-engines-etc)
      - [For math](#for-math)
      - [Algorithms libs](#algorithms-libs)
      - [For phpstorm](#for-phpstorm)
- [Common useful links](#common-useful-links)
- [Полезные инструменты](#--------------------)
- [Symfony](#symfony)
  * [Статьи](#------)
  * [Примеры (репозитории):](#----------------------)
- [Архитектуры (DDD, Clean Architecture, Hexagonal)](#-------------ddd--clean-architecture--hexagonal-)
    + [Модель](#------)
    + [Entities](#entities)
      - [VO](#vo)
      - [Validation](#validation)
    + [Про DTO](#----dto)
    + [CQRS](#cqrs)
    + [Clean Architecture](#clean-architecture)
- [OOP](#oop)
  * [OOP principles](#oop-principles)
    + [Encapsulation](#encapsulation)
    + [inheritance](#inheritance)
    + [abstraction](#abstraction)
    + [polymorphism](#polymorphism)
    + [Наследование vs композиция](#-------------vs-----------)
    + [Инвариант](#---------)
  * [Relationship between classes](#relationship-between-classes)
  * [SOLID, KISS, YAGNI, DRY](#solid--kiss--yagni--dry)
    + [Single Responsibility Principle](#single-responsibility-principle)
    + [The OpenClosed Principle](#the-openclosed-principle)
    + [L - LSP - Liskov Substitution Principle](#l---lsp---liskov-substitution-principle)
    + [Interface Segregation Principle](#interface-segregation-principle)
    + [Dependency Inversion Principle](#dependency-inversion-principle)
  * [IoC](#ioc)
  * [Закон Деметры](#-------------)
  * [GRASP](#grasp)
    + [Information Expert](#information-expert)
    + [Creator](#creator)
    + [Controller](#controller)
    + [Low Coupling and High Cohesion](#low-coupling-and-high-cohesion)
    + [Pure Fabrication](#pure-fabrication)
    + [Indirection](#indirection)
    + [Protected Variantions](#protected-variantions)
    + [Polymorphism](#polymorphism)
- [СУБД](#----)
    + [Vertica](#vertica)
    + [Партицирование](#--------------)
    + [Шардинг](#-------)
    + [Репликация](#----------)
- [REST, SOAP ...](#rest--soap-)
- [EventStorming](#eventstorming)
- [Golang](#golang)
- [Bash](#bash)

## PHP

#### Articles
- https://phptherightway.com/
- https://riptutorial.com/php/example/5441/reading-a-large-file-with-a-generator
- https://habr.com/ru/post/437972/ - базовое (про сессии и куки)

#### Packages
Пакеты, с которыми я столкнулся в ходе разработки

- markrogoyski/math-php (Powerful Modern Math Library for PHP)
- zircote/swagger-php
- php-di/php-di
- guzzlehttp/guzzle
- monolog/monolog
- twig/twig
- webmozart/assert
- swiftmailer/swiftmailer
- ramsey/uuid (uuid generator)

queryBuilder: 
- https://github.com/shadowhand/latitude
- https://github.com/rambler-digital-solutions/hydrogen

security
- https://github.com/Roave/SecurityAdvisories

filesystems
- https://github.com/thephpleague/flysystem   a filesystem abstraction which allows you to easily swap out a local filesystem for a remote one.

For math (обертки над gmp и BcMath)
- brick/math A PHP library to work with arbitrary precision numbers.
- https://github.com/moneyphp/money

##### For require-dev
- phpunit/phpunit
- fzaninotto/faker

##### Static analysis tools

- https://habr.com/ru/company/badoo/blog/426605/ как баду юзать сразу phpstan, phan и psalm

- https://github.com/squizlabs/PHP_CodeSniffer detects violations of a defined set of coding standards.
    - https://github.com/slevomat/coding-standard Slevomat Coding Standard for PHP_CodeSniffer provides many useful sniffs
    - https://github.com/PHPCompatibility/PHPCompatibility PHP Compatibility check for PHP_CodeSniffer
- sensiolabs-de/deptrac ( static code analysis tool that helps to enforce rules for dependencies between software layers)
- psalm - static analysis tool for PHP that helps you identify both obvious and hard-to-spot bugs in your code.
- phpstan - PHPStan finds bugs in your code without writing tests

##### Profiling tools

- first, collect app metrics for monitoring important buisness hotspots

- pinba - (for all prod req) сервис для получения realtime
-статистики от работающих приложений без накладных расходов на её сбор
    - https://github.com/tony2001/pinba_engine
    - https://github.com/badoo/pinba2
    - https://habr.com/ru/company/badoo/blog/319934/
    - https://habr.com/ru/company/badoo/blog/149695/
    
- xhprof (for small 0.1 % of requests)  (, xshprof, lifeprof)
    - https://github.com/badoo/liveprof-ui -  профилирования всех запросов с интерфейсом для анализа изменения производительности приложения.
    
    https://zinvapel.github.io/it/prog/lang/2019/01/10/xhprof/
    https://habr.com/ru/post/145895/
    - https://github.com/tideways/php-xhprof-extension - xhprof optimized for PHP7
    - https://github.com/phacility/xhprof for ui
    
- https://github.com/NoiseByNorthwest/php-spx (require centos 7+)
- https://github.com/blackfireio/php-sdk

##### PSR

- php-fig/fig-standards
- psr/log

Статьи, зачем вообще этот psr:
- https://habr.com/ru/post/458484/ PSR Стандарты - краткое описание
- https://elisdn.ru/blog/80/some-reasons-to-learn-phpdoc
- https://mwop.net/blog/2015-01-26-psr-7-by-example.html psr7 на примерах

#####  Template engines etc 
- cebe/markdown
- twig
- ezyang/htmlpurifier

##### Algorithms libs
- bandwidth-throttle/token-bucket - Implementation of the Token Bucket algorithm in PHP.

##### For phpstorm
- brendt/phpstorm-photon-theme 

## Common useful links

- zualex/devmap - Карта развития веб-разработчика
- tlbootcamp/tlroadmap - Карта навыков и модель развития тимлидов
- https://habr.com/ru/search/?target_type=posts&q=тимлид&order_by=relevance - статьи на хабре по тимлидству

тесты по php:
- https://www.w3schools.com/quiztest/quiztest.asp?qtest=PHP (для джуна)
- https://corp.mamba.ru/ru/test/ (последний: 232)

## Полезные инструменты

- https://github.com/centrifugal/centrifugo - Scalable real-time messaging server in language-agnostic way.

Можно юзать для чатов, как микросервис доставки сообщений на клиент.

- https://github.com/walkor/Workerman - An asynchronous event driven PHP socket framework. Supports HTTP, Websocket, SSL and other custom protocols
- https://github.com/php-enqueue/enqueue-dev (если не юзать messanger symfony) - Предоставляет общий способ для программ создавать, отправлять, читать сообщения.


## php jit, vm, byte code

- https://habr.com/ru/company/oleg-bunin/blog/481092/ хорошее описание
- https://habr.com/ru/company/mailru/blog/341912/
- https://habr.com/ru/company/otus/blog/509598/
- https://thephp.website/en/issue/how-does-php-engine-actually-work/ (пару слов о том, как php работает)

исходный код ->  (компилируется в) байт код (opcodes) > интерпретатор -> машинный (native) 


### classic php

![img ex1](https://skr.sh//i/090720/jRGmEN3O.jpg)

![img ex11](https://skr.sh/i/090720/94bWre4K.jpg)

Упрощенная схема
- сервер принмает запрос
- компилирует его в байт код (ru.wikipedia.org/wiki/Байт-код: исходный код -> байт код > интерпретатор -> машинный (native) 
код)
- тот поступает на исполнение VM (виртуальной машине)

Виртуальная машина, исполняя байт-код, может вызывать и другие PHP-файлы, которые опять перекомпилируются в байт-код и опять исполняются.

По завершению выполнения запроса вся информация, которая к нему относится, включая байт-код, удаляется из памяти. То есть каждый PHP-скрипт должен быть скомпилирован на каждом запросе заново. 

Подобнее
- Первая фаза управляется лексическим анализатором PHP
. Он отвечает за сопоставление ключевых слов языка вроде function, return и static с отдельными частями, 
которые обычно называются токенами. Каждый токен зачастую дополняется метаданными, необходимыми для следующей фазы.

- Вторая фаза управляется парсером PHP. Он отвечает за анализ одного или нескольких токенов, а также за сопоставление их с 
шаблонами языковых структур. Например, $foo + 5 распознаётся как двоичная операция «сложения», а переменная $foo и число 5 распознаются как операнды. 
Парсер рекурсивно строит абстрактное дерево синтаксиса (AST). Обычно работа лексического анализатора и парсера считается одной задачей.

- Третья фаза — компилирование. AST
 преобразуется в упорядоченную последовательность инструкций-опкодов (байт код). Каждый опкод можно 
считать низкоуровневой операцией виртуальной машины Zend. Полный список поддерживаемых опкодов можно посмотреть здесь.

- последняя фаза — исполнение. ВМ Zend выполняет каждую задачу, описанную в опкодах, и генерирует результат.

Первые три фазы (лексический анализатор, парсер и компилятор) объединены в «конвейер» (pipeline). Причём третья фаза занимает гораздо 
больше времени и потребляет больше ресурсов (памяти и процессора). 
Чтобы снизить вес фазы компилирования, в PHP 5.5 ввели расширение Zend OPCache. 

### php + OPcache

![img ex2](https://skr.sh/i/090720/0Cl00Zgr.jpg)

Главная задача OPcache — избавиться от перекомпиляции скриптов на каждом запросе. Он встраивается в специально предназначенную для него точку, 
перехватывает все запросы на компиляцию и кэширует скомпилированный байт-код в shared memory
 (кеширует выходные данные фазы компилирования (байт код) в общую память (shm).

При этом экономится не только время компиляции, но и память, потому что раньше память под байт-код выделялася в адресном пространстве
каждого процесса, а теперь он существует в единственном экземпляре.

### PHP + OPcache + Preload

opcache.preload = "сцценарий загрузки php файлов". Выполняется единожды при запуске fpm, apach...

технология уже включена в PHP 7.4 и дает возможность задать набор файлов, загрузить их при старте сервера и сделать все функции из этих файлов **постоянными**.

Одна из проблем, которую решает preloading-технология — это проблема связывания классов. Дело в том, что когда мы просто компилируем файлы в PHP, 
каждый файл компилируется отдельно от других. Делается это потому, что каждый из них может изменяться отдельно.
 
Соответствено, при каждом вызове include/require копируются сигнатуры классов и функций из общей памяти в память процесса-воркера, 
а также делается различная вспомогательная работа. И эта работа должна быть сделана для каждого запроса, так как по его окончании память
процесса-воркера очищается.
 
Preloading позволяет связать классы изначально (не в runtime), а сделать это единожды.И, соответственно, генерировать код более оптимально.
Как минимум, для фреймворков, которые будут загружаться с помощью preloading’а.
Кроме того связанные классы теперь хранятся не в адресном пространстве каждого процесса, а в shared memory
, и следовательно общее потребление памяти падает.

Нюансы:
- Так как все preload-файлы компилируются только при запуске, помечаются как immutable и не перекомпилируются в дальнейшем, 
единственный способ применить изменения в этих файлах — перезапустить (reload или restart) PHP-FPM/Apache/и т. п.

- глобальные константы, в отличие от констант/полей класса, принудительно очищаются после окончания фазы preload, 
в то время как константы/поля класса — резолвятся и сохраняются. Это приводит к тому, что во время выполнения запроса нам 
приходится определять глобальную константу заново, в результате чего она может получить другое значение.


В целом, opcach (и jit далее), имеет наилучший эффект для CPU-bound приложений.
Существует два типа возможности занять поток (процесс): https://stackoverflow.com/questions/868568/what-do-the-terms-cpu-bound-and-i-o-bound-mean

- CPU Bound— блокировка, когда поток занят непосредственно вычислениями. Здесь необходимо позаботиться о том, чтобы длинная операция не блокировала потоки пула потоков .NET (ThreadPool), а работала отдельно и синхронизировала возврат результата.
- IO Bound— блокировка, ожидание результата от устройств ввода-вывода — тут асинхронный подход имеет максимальный эффект, так как, по сути, мы занимаемся ожиданием, и наши потоки могут выполнять пустую работу.

IO Bound хорошо решается асинронным подходом работы потоков (ReactPHP и тд).
CPU Bound - наращиванием мощностей, использованием RoadRannera либо демонов на Go

### PHP + OPcache + Preload + Jit

JIT реализуется как часть OPcache.

![Img exm1](https://skr.sh/i/090720/r9OJMn38.jpg)


После того, как байт-код скомпилирован и оптимизирован, для него запускается JIT-компилятор, который уже не работает с исходными текстами.
 Из PHP байт-кода JIT-компилятор генерирует нативный код, после чего в байт-коде изменяется адрес первой инструкции (по сути дела функции).

После этого нативный, уже сгенерированный код начинает вызываться из существующего интерпретатора без каких-либо изменений.

Упрощая вещи: когда JIT работает должным образом, ваш код не будет выполняться через Zend VM, вместо этого он будет 
выполняться непосредственно как набор инструкций уровня процессора.

## About php working mode: cgi, Fast-cgi (php-fpm), mod_php

- https://thephp.website/en/issue/how-does-php-engine-actually-work/ (пару слов о том, как php работает)
- http://xandeadx.ru/blog/php/866
- https://lectureswww.readthedocs.io/5.web.server/cgi.html (общее про cgi и его недостатки)
- https://hostiq.ua/wiki/php-modes/

PHP в режиме FastCGI в памяти висит сам php интерпретатор, а не какой-то конкретный php-скрипт.

## SPL



## Symfony

### Статьи

- http://ocramius.github.io/doctrine-best-practices/#/10 
- https://medium.com/phpyh/правильная-регистрация-консольных-команд-в-symfony-di-f7536c254926
 правильная регистрация консольных команд (lazy)

### Примеры (репозитории):

- https://github.com/symfony/demo

- рейтинг в гитхабе по языку php (можно много интересного найти)
  https://github.com/search?q=stars%3A%3E1000+language%3APHP+state%3Aopen+language%3APHP&type=Repositories

- Шаблон апи на симфони 4 (регистрация/авторизация/профиль юзера):
  https://github.com/tarlepp/symfony-flex-backend
  
- Простенький сайтик для шаринга фото на симфони 5 пхп 7.4 с попыткой отказаться от геттеров и сеттеров:
  https://github.com/svbackend/cropofil
  
- Апи на симфе 4, позволяет получить список фиььмов и рекомендации к понравившимся:
  https://github.com/svbackend/my-art-lib


Полезные курсы:

- от елисеева
- https://symfonycasts.com/  (или Knpuniversity)

Топ компоненты, бандлы и пакеты:

- symfony/notifier
- symfony/messenger
 - Symfony/mailer
 - https://github.com/lexik/LexikJWTAuthenticationBundle
- https://gist.github.com/fesor/fb1d53e8e4e427c59b930559da83d9a3 - RequestObjectResolver, для валидации DTO
 из реквеста (до попадания в контроллер)
- https://github.com/nelmio/NelmioCorsBundle - Adds CORS (Cross-Origin Resource Sharing) headers support
(статья про CORS в symfony https://blog.liplex.de/symfony-cors-listener/)

Админки:
- EasyAdminBundle

Bundles for dev:
- dmaicher/doctrine-test-bundle -  bundle to isolate your app's doctrine database tests and improve the test performance
- https://github.com/paratestphp/paratest -  Parallel testing for PHPUnit
- https://github.com/lchrusciel/ApiTestCase - решение по интеграционному тестированию внешних апи

## Архитектуры (DDD, Clean Architecture, Hexagonal)

Предметно-ориентированное проектирование (Domain-driven design, DDD
) — это набор принципов и схем, направленных на создание оптимальных  систем объектов. 
Сводится к созданию программных абстракций, которые называются моделями предметных областей. 
В эти модели входит бизнес-логика, устанавливающая связь между реальными условиями области применения продукта и кодом.

Статьи по Hexagonal
- https://www.thinktocode.com/2018/07/19/ports-and-adapters-architecture/

Статьи по DDD
- https://matthiasnoback.nl/2018/06/doctrine-orm-and-ddd-aggregates/
- https://matthiasnoback.nl/2018/03/ormless-a-memento-like-pattern-for-object-persistence
/ интересная статья о сохранении моделей без орм (через снепшоты внутреннего состояния)

Выжимки из синей и красной книги
- https://dddcommunity.org/library/vernon_2011/

Видео:
- https://www.youtube.com/watch?v=fWU8ZK0Dmxs - Уди рассказывает про race condition
довольно часто важные бизнес правила будут в перемешку с правилами, нарушения которых не приводят к проблемам (типа лайкнуть архивные баннер).
Нужно быть аккуратным с защитными условиями бизнес правил в сущностях, для которой может быть гонка.
Есть важные правила которые нельзя нарушать. Которые например на тебя налагает не менеджер или там продукт оунер а законодательство страны в которой твой продукт работает
Если "а что будет, если я выключил промокод, а в это время его применили" - это не критично.



Проектирование без учета ORM
Когда вы узнаете, как проектировать доменные объекты с использованием шаблонов, управляемых доменом, 
вам сначала нужно избавиться от идеи, что проектируемые объекты когда-либо будут сохраняться

When to use - if you have complicated and everchanging business rules

BUT - if you have  simple not-null checks  and a couple of sums to calculate, a Transaction script is better bet


#### Модель
Модель – это всеохватывающее определение для всего доменного кода.
Как "модель солнечной системы" и "модель киоска с шаурмой". С кучей сущностей, расчётов и правил внутри. А не какой-то один класс Model.
"Доменная модель" подразумевает, что ты разбираешься с доменом, а не просто объектики лепишь. Основная суть в том что бы понять какие у тебя есть важные правила и как реагировать на них. 

Во многих фреймворках в отличие от этого класс Model определяет "модель данных БД",  "модель ввода" или что-то ещё мелкое.
В Eloquent это "модель данных БД". В Yii это "модель ввода с валидацией".

#### Entities 
Cодержат бизнес-правила, независимые от приложения. И они не просто объекты с данными.
Entities могут содержать ссылки на объекты с данными, но основное их назначение в том, чтобы реализовать методы бизнес-логики,
 которые могут использоваться в различных приложениях.

An object model of the domain that incorporates both behavior and data.
You’ll find objects that mimic  the data in  the business  and objects  that  capture  the  rules  the businessuses.

Анемик модели это хорошо и норм, просто это не модели а структуры
если вам надо сохранить и считать данные  (CRUD) а логики не надо то структура самое то

О анемик модель vs reach models
- https://thevaluable.dev/anemic-domain-model/ Anemic Domain Model vs Rich Domain Model with Examples
- http://ocramius.github.io/doctrine-best-practices/#/26
- https://habr.com/ru/post/470021/ Анемичная и «Богатая» модель в контексте GRASP шаблонов
- https://habr.com/ru/company/mobileup/blog/335382/ - статья по clean architecture 

Конструктор можно делать приватным + именнованые для разных кейсов создания сущности

##### VO

- не имеет идентификатора (в отличии от агрегата)
- иммутабельный
- валидирует состсяние при создании
- все состояние VO можно легко "серриализовать" и передавать между процессами, т.к. не имеет идентификатора


Например, есть class UrlValueObject = при своении в конструкторе можем чекать все что надо, дальше мы уже можем преедавать
урл не как строку, а как VO. И он immutable. Для изменения нужно создать новый инстанс объекта с нужным значением



**Тесирование**
В сущности не нужны добавлять getter-ы только ради тестов (чтобы проверить "правильность" созданной сущности).

Конструктор не тестят в принципе. Сущность либо создалась с корректным состояние, либо упала с DomainException.

Методы смены состояний можно проверить через Domain Events, которые хранит в себе агрегат.


Агрегаты строишь вокруг инвариантов, а не вокруг "групп" данных. 
На агрегатах у тебя только "командные" методы с :void
В самом простом случае на чтение ты данные забираешь при помощи DBAL (ReadModel) из таблицы напрямую, 
минуя сам агрегат. В сложном — EventSourcing и проекции, тогда можно +- любые данные на чтение
собирать на базе событий. Но EventSourcing лучше пробовать не в перую очередь и только когда поймёшь, 
что он реально нужен проекту и что ты понимаешь, что ты делаешь.

в dto вместо геттеров и сеттеров публичные свойства с @psalm-immutable.
в модель тоже геттеры/сеттеры не нужны никогда. 
в value object-ах лучше делать toString`/`to*. ну и всё)

доменные события — это внешний контракт агрегата. его API. 
вместо геттеров ты получаегшь куда более мощную информацию об изменениях


##### Validation

http://gorodinski.com/blog/2012/05/19/validation-in-domain-driven-design-ddd/

#### Про DTO

Dto
 нужны только для того, чтобы передавать данные между уровнями. Например:
  - передача данных с уровня инфраструктуры в уровень сервиса (или домена).
  - возврат данных с read model. Для того, чтобы отобразить данные, не нужно подымать сложные domain
   модели с поведением.
   
Чтобы данные не передавать массивом, создается объект с public полями (ide
 подскажет поля объекта при использовании и тип, при наличии phpdoc).

- это грубо говоря массив, который мы перекидываем из внешнего слоя инфраструктуры в слой приложения (или домена).
- объект с заранее известными полями без какого-либо поведения
- в dto вместо геттеров и сеттеров публичные свойства с @psalm-immutable.
- без валидации и контроля типов (кроме psalm).
Необходимые проверки на типы и корректность данных должна выполнять использующая сторона - сервисы, репозитории, ентити.

- как правило, для dto
 справедливо, что он должен инстанцироваться с заполнением определенных полей. Нужно добавить конструктор и принимать эти обязательные поля, 
а остальные поля заполнять из реквеста (формы в контроллере) путем присваивания публичных полей (или автоматически из валидатора форм).
Но в общем, dto после создания не надо модифицировать, это что-то вроде сообщения


Best way to write DTO - constructor + public properties + Psalm @immutable to control for access.
then you do an optimal class and check immutability in ci instead of runtime
​just write once from constructor, that's it
all modifications with "with" methods + cloned return to keep immutability
but DTO generally should not be modified, it's like a message


Иммутабельность Это св-во VO. Но т.к. DTO-ки как правило не модефицируют, это и к нему тоже косвенно можно отнести


-------------
#### CQRS

Материал:
- https://martinfowler.com/bliki/CQRS.html
- https://www.youtube.com/watch?v=RfnySciLUhc&feature=youtu.be

Read and write models

- Write models - Domain models (ak DDD) domain models (агрегаты, сущности, vo) держим логику. Данные группируем по сущностям так, как удобно для логики
- Read models. Используются для фронта например (списков, форм и тп)
Для чтения юзаем отдельные простые структуры данных. Заполняем их напрямую из результатов запросов (без использования write models)


- https://github.com/prooph/event-sourcing - Provides basic functionality for event sourced aggregates
 (чтобы самому не реализовывать. Однако, добавляет зависимость в доменный слой)
 
Пример
- https://github.com/dmitrymendelson/cqrs_es_example (dirty example of cqrs)
- https://github.com/ShittySoft/lyska-2020-cqrs-es-works

-------------

#### Clean Architecture 

- https://softwareengineering.stackexchange.com/questions/357052/clean-architecture-use-case-containing-the-presenter-or-returning-data

About communication Use case adn  presenter?

- https://softwareengineering.stackexchange.com/questions/303478/uncle-bobs-clean-architecture-an-entity-model-class-for-each-layer/303480#303480
 
- An entity/model class for each layer https://habr.com/ru/company/mobileup/blog/335382 
(пункт Заблуждение: Обязательность маппинга между слоями).
 Если у вас сложное приложение с логикой бизнеса и логикой приложения, и/или разные люди работают над разными слоями, то лучше разделять данные между слоями (и маппить их). 
 Также это стоит делать, если серверное API корявое. Но если вы работаете над проектом один, и это простое приложение, то не усложняйте лишним маппингом.




------
## OOP

- https://oopru.github.io/

Статьи:
- https://martinfowler.com/bliki/TellDontAsk.html

file://C:/рабочие/облако/PHP/книги/прочел/Патерны%20проектирования%20refactoringguru.pdf
ст 14 -18


- ООП — парадигма разработки, в которой приложения описываются взаимодействием различных объектов.
- Объекты являются сущностями, у которых есть свойства и поведение. Обычно объекты являются экземплярами какого-нибудь класса. 
Классы образуют иерархию наследования.

ООП определяется через 4 принципа: инкапсуляция, наследование, абстракция, полиморфизм


### OOP principles

#### Encapsulation
Инкапсуляция (способ логической группировки (упаковка) данных и функций в единый компонент (с) Википедия)

Инкапсуляция - главный механизм обеспечения инвариант класса

"Любая программная сущность, обладающая нетривиальным состоянием, должна быть превращена в замкнутую систему, 
которую можно только перевести из одного корректного состояния в другое". Чтобы этого добиться, необходимо выполнять:

+ четкое разделение интерфейса и реализации класса, и строгое соблюдение этих границ
+ для взаимодействия с объектов наружу выставляется только спецификация (интерфейс) объекта
+ при этом детали реализации должны быть скрыты от клиентской стороны
+ для соблюдения границ используется принцип "сокрытие информации". Он обеспечивает ограничение доступа одних компонентов к деталям реализаций других.
Реализуется использованием различных модификаторов доступа. Яявляется самым надежным способом сохранения инкапсуляции

Таким образом, для взаимодействия с объектов наружу выставляется только спецификация (интерфейс) объекта,
при этом скрываются детали реализации от клиентской стороны с помощью "сокрытия информации" (используя модификаторы доступа).

- https://www.youtube.com/watch?v=X7-1L5F8zeI&list=PLOKAzMGgK9xvxjGdkx4j5q0Sjb0YilCMA&index=4

#### inheritance
наследование - позволяет описать новый класс  на основе уже существующего и дополнить его, или частично изменить его поведение.

- позволяет объединить переиспользование кода и силу полиморфизма
- классы могут образовывать иерархию
- Класс, от которого производится наследование, называется базовым или родительским. Новый класс – потомком, наследником или производным классом.
- наследник полностью удовлетворяет спецификации родительского, 
однако может иметь дополнительную функциональность. С точки зрения интерфейсов, каждый производный класс полностью реализует интерфейс родительского класса. Обратное не верно.

Плюсы, минусы:
- (+) повторное использование существующего кода
- (+) полиморфность родителя и дочерних класов

Полиморфность наследования же в том, что мы можем там, где клиентский код ожидает от нас родительский класс, дать объект типа
дочернего класса, и вызвать нужный метод базового класса. Компилятор поймёт, что нам подсунули наследника, и сначала начнёт искать реализацию этого метода у наследников.

- (-) подклассы всегда следуют интерфейсу родительского класса. Вы не можете исключить из подкласса метод, объявленный в его родителе
- (-) при возрастании иерархии, нужно помнить о проблеме хрупких базовых классов. 
Внесение изменений в базовый класс может сломать поведение дочерних. 
- (-) Поскольку подклассу доступны детали реализации родительского класса, то часто говорят, что наследование нарушает 
принцип "сокрытие информации" (не инкапсуляции)

Предок должен быть закрыт от наследников настолько, насколько это возможно.
Например, для реализации патерна "шаблонный метод)".
Абстрактный класс описывает шаблон алгоритма и предоставляет возможность дочерним классам конкретезировать некоторые шаги.
В соответствии с этим паттерном, поведение абстрактного родительского класса разделяют на две части:
- Поведение в неабстрактных методах. Это общий код, формирующий шаблон (скелет) алгоритма. Дочерний класс наследует реализацию этих методов.
 Неабстрактные методы рекомендуется объявлять с модификатором final. Это позволяет избавиться от одной из проблем с сокрытием – 
 исключить возможность переопределения поведения в дочерних классах.
- Поведение в абстрактных методах. Конкретная реализация этого поведения выполняется дочерними классами.
 В теле метода размещается код, который описывают специфичную для дочернего класса реализацию некоторых шагов алгоритма. 
 Дочерний класс наследует только интерфейс (сигнатуру) абстрактного метода.

Этот паттерн снижает силу зацепления по реализации в рамках иерархии, за счет разделения кода на abstract методы, реализованные в дочерних классах, 
и final методы, реализованные в абстрактном родительском классе. За счет ограничивающих ключевых слов вы, в принципе, 
запрещаете переопределять реализацию в процессе наследования. Пределы изменения реализации в дочерних классах четко ограничены абстрактными методами, 
т.к. остальные методы помечены ключевым словом final.

Сформированное эмпирически правило гласит, что если можно переиспользовать код без наследования, то лучше так и сделать (юзать композицию).
- Во-первых, мы полностью убрали зацепление классов по реализации. В этом случае классы разделяют только сигнатуры методов и
 полностью отсутствует какое-либо унаследованное поведение. Классы объявлены как final, а значит исключаются все связанные с
 наследованием реализации проблемы: хрупкость базового класса, запутанность потока выполнения при использовании открытой рекурсии и т.д.
- Детали реализации поведения надежно скрыты за интерфейсом и теперь не являются частью контракта, что существенно повышает качество архитектуры приложения.
  

Классический пример: квадрат является фигурой, как и круг. И их можно нарисовать. Но по разному.

- https://www.thoughtworks.com/insights/blog/composition-vs-inheritance-how-choose
- http://programming-lang.com/ru/comp_programming/satter/0/j84.html композиция против наследования

#### abstraction
-Абстрагирование – отделение существенного от несущественного. (как данных, так и поведения)
- Абстракция — это модель объекта реального мира, в которой рассматриваются отдельные значимые характеристики (данные, поведение) для данного контекста, 
исключая незначемые.
- Абстракция - правильное разделение программы на объекты

**Абстракция не подразумевает наличие наследования. Абстракция не может существовать без инкапсуляции!**

В контексте ООП, абстракция проявляется в 2х видах :
1)	в абстрагировании от незначительных в контексте программы характеристик объекта. Когда мы моделируем некий объект, мы можем отказаться от его частей (характеристик), не важных в контексте программы.
Представьте, что мы описываем яблоко. Оно имеет: цвет, вкус, калорийность, кол-во зерен и т.д. Исчерпывающее ли это описание? Нет. Об объекте можно думать по разному: и как о наборе клеток, и как о чем-то, что можно съесть и тп.

Как тогда описать яблоко, при написании проги для сортировки яблок? Так как нужно программе:  если программа сортирует яблоки по весу и цвету, то ей нужна инфа только об этом и не больше.
Необходимо использование только тех характеристик объекта, которые с достаточной точностью представляют его в данной системе.

2)	в абстрагировании от деталей реализации. когда мы имеем больше описания об объекте, чем нужно остальной части программы (клиенской стороне).

Пример: объект файл. Остальной программе нужны только методы записи и чтения (остольное поведение отбросили из абстракции, т.к. оно для нас не нужно). 
Хотя понятно, что объект файл будет еще содержать системный указать, информацию о текущей позиции в файле и прочие внутренние данные.

В таком случае мы тоже применяем абстракцию, чтобы скрыть ненужные детали реализации от остальной части кода (с помощью механизма инкапсуляции). А всю работу с объектом производить через известный интерфейс, при этом не вдаваясь в подробности внутренней реализации.


Выводы. Абстракция: основа ООП, позволяет работать с объектами, не вдаваясь в особенности их реализации. Проявляется в 2х видах: 
1)	в абстрагировании от незначительных в контексте программы характеристик объекта
2)	в абстрагировании от деталей реализации, путем сокрытия ненужных деталей реализации от клиента, используя инкапсуляцию. 
Вся работа с объектом ведется только через интерфейс. Главное, чтобы инициализированный объект выполнял возложенную работу,
 а как он это делает внутри - не важно (реализация скрывается от внешнего мира с помощью инкапсуляции). 

Про Уровни абстрагирования - приложения разделяется на уровни абстрагирования (от верхнего к нижним). Каждый уровень абстрагирует реализацию объектов нижних уровней. Ему не важно, как они устроены внутри, главное, чтобы они выполняли свою работу (объекты эти находятся на более низком уровне абстракций).
Самые нижние уровни выполняют самую черную работу. Похожим образом работает ОС, различиные сетевые протоколы...

Про абстракции. Практически все компьютеры работают в двоичной системе 0 и 1 все что "выше" это уже абстракция.
 Все наши эти if, else, ArrayList все это абстракции по сути своей. И даже 0 и 1 это абстракция, 
 а изначально это состояние транзистора - включен/выключен.
  И транзистор по сути абстракция, через которую получается управлять потоком электронов, то есть током. 
  И понятие электрический ток - тоже абстракция. А дальше уже квантовая физика :-) Хотя там абстракций еще больше...

#### polymorphism
- https://habr.com/ru/post/37610/

полиморфизм - один интерфейс - множество реализаций
- возможность объектов с одинаковой спецификацией (интерфейсом) иметь различную реализацию.
- использование объектов с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.
- способность программы выбирать различные реализации при вызове операций с одним и тем же названием.
    
Отделение интерфейса от реализации позволяет коду, использующему интерфейс не зависить от деталей реализации.
Или от того факта, что она поменялась целиком и полностью.

- статический полиморфизм (адресс метода определяется во время компиляции) - раннее (статическое) связывание / связывание во время компиляции / перегрузка метода(оператора) (В том же классе)

Механизм реализации:
    - перегрузка методов (несколько различных определений для одного имени метода в одной области видимости)
    - перегрузка операторов
    
       class Calculation {  
         void sum(int a,int b){System.out.println(a+b);}  
         void sum(int a,int b,int c){System.out.println(a+b+c);}  
       
         public static void main(String args[]) {  
           Calculation obj=new Calculation();  
           obj.sum(10,10,10);  // 30
           obj.sum(20,20);     //40 
         }  
       } 
    
- динамический полиморфизм (адресс метода определяется во время выполнения) -  позднее (динамическое) связывание / Связывание во время выполнения / Переопределение метода. (В разных классах)

Механизм реализации: 
    - переопределение абстрактных методов в наследнике (родитель не имеет базовой реализации)
    - переопределение виртуальных методов в наследнике (переопределение базовой реализации родителя)
    - реализация методов интерфейса

      class Animal {    
         public void move(){
            System.out.println("Animals can move");
         }
      }
      
      class Dog extends Animal {
      
         public void move() {
            System.out.println("Dogs can walk and run");
         }
      }
      
      public class TestDog {
      
         public static void main(String args[]) {
            Animal a = new Animal(); // Animal reference and object
            Animal b = new Dog(); // Animal reference but Dog object
      
            a.move();//output: Animals can move
      
            b.move();//output:Dogs can walk and run
         }
      }

#### Наследование vs композиция
- https://medium.com/swlh/final-classes-in-php-9174e3e2747e
- https://habr.com/ru/post/482154/ чуть более длинная статья с большими разъяснениями 
- http://programming-lang.com/ru/comp_programming/satter/0/j84.html тут пару неплохих аргументов


#### Инвариант
Инвариант - выражение, которое определяет непротиворечивое (консистентное) внутренее состояние объекта
Это также означает, что при создании и последующиех вызовах любых методов объекта в любой последовательности,
его инвариант неизменяется (внутренее состояние остается непротиворичивым).

Инкапсуляция позволяет сохранить инвариант.
Для этого, следует ограничить использование геттеорв, и тем более сеттеров, которые нарушают инкапсуляцию класса и
позволяют изменять состояние объекта, не позволяя объекту обеспечивать собстевенный инвариант.

### Relationship between classes

- "является" - отноешение между базовым классом и его наследником

### SOLID, KISS, YAGNI, DRY


KISS -keep it simple stupod - большинство систем работают лучше всего, если они остаются простыми, а не усложняются

YAGNI (You aren't gonna need it)— игнорируй изменения, которых скорее всего не будет. 
Затык тут в «скорее всего», потому что будущее мы предсказывать не умеем.

TellDon'tAsc (похоже на Information Expert из GRASP) - https://martinfowler.com/bliki/TellDontAsk.html

DRY - don't repead yourself - Каждая часть знания должна иметь единственное, непротиворечивое и авторитетное представление в рамках системы


Single Choice Principle - всякий раз, когда система программного обеспечения должна поддерживать множество альтернатив, 
их полный список должен быть известен только одному модулю системы

SOlID
- https://habr.com/ru/post/446816/
- https://habr.com/ru/post/208442/
- http://sergeyteplyakov.blogspot.com/2014/10/about-design-principles.html
- http://sergeyteplyakov.blogspot.com/2014/10/solid.html

цели принципов: 
- SRP предназначен для борьбы со сложностью; 
- OCP помогает в вопросах расширяемости и параллельной разработки; 
- LSP указывает, как использовать наследование «правильно»;
- ISP выделяет разные аспекты класса; 
- DIP должен бороться с признаками плохого дизайна в архитектуре

#### Single Responsibility Principle
- Модуль должен иметь только одну причину для изменения.  (Чистая_архитектура. Роберт Мартин, с. 79)
- На каждый объект должна быть возложена одна единственная обязанность

В контексте принципа SRP мы будем называть обязанностью причину изменения.
 Если вы можете найти несколько причин для изменения класса, то у такого класса более одной обязанности

**Нарушение.**
Нарушение этого принципа применяется к классам, содержащим в себе различную функциональность, которая может менятся в разное время по разным причинам.
Например, классы бизнес-логики, которые знают о пользовательском интерфейсе или о базе данных; класс windows
-сервиса c кучей бизнес-логики; статические утилитные классы, изменяющие глобальное состояние и т.п.


**Цель SPR**
- борьба со сложностью. При разростании класс затрудняется навигация, на глаза попадаются ненужные детали, связанные с другим аспектом 
(кол-во деталей превышает 7 +-2)
- Любой сложный класс/модуль должен быть разбит на несколько простых составляющих, отвечающих за определенный аспект поведения (единственную ответственность),
  что упрощает как понимание, так и будущее развитие. 

Я хочу иметь возможность сосредоточиться на сложных аспектах системы по отдельности, 
поэтому когда мне становится сложно это делать, я начинаю разбивать классы и выделять новые.

SRP – это способ поиска скрытых абстракций, достаточно сложных, чтобы им отвели отдельную именованную сущность и спрятали в их недрах все детали.
Разделение классов на составляющие диктуются не «осями изменений», а здравым смыслом и попыткой справиться с нарастающей сложностью системы.


**Примеры**: 
1) смешивание логики и инфраструктуры: бизнес-логика смешана с представлением, слоем персистентности, находится внутри WCF или windows-сервисов и т.п.
2) класс/модуль решает задачи разных уровней абстракции: вычисляет CRC и отправляет уведомления по электронной почте; 
разбирает json-объект и анализирует его содержимое и т.п.
4) god-объекты
3) Класс, который запрашивает данные из БД и выводит их в определённом формате в .txt-файл.
Содимся и думаем, что может измениться со временем:
- бд (или библиотека для работы с ней)
- формат данных (900 USD или 900.00$? 20190826T130000 или час дня двадцать шестого августа 2019 года)
- тип файла для вывода

Если в описании маленькой программной сущности (класс или метод, например) фигурирует союз «И», это такой большой красный флаг с надписью «у тебя будут проблемы,
 если ты не перепроверишь этот кусок код

**Anti-SRP** – Принцип размытой ответственности. Чрезмерная любовь к SRP ведет к обилию мелких классов/методов и размазыванию логики между ними.

Если приложение не модифицируют таким образом, что эти обязанности изменяются порознь, то и разделять их нет необходимости. 
Более того, разделение в этом случае попахивало бы ненужной сложностью.

"Если несколько программных сущностей изменяются вместе по одним и тем же причинам, то на самом деле это одна программная сущность. 
Объедините их немедленно."

На практике я довольно часто говорю о том, что класс нарушает SRP, но при этом я никогда не апеллирую к «осям изменений». 
Я говорю:
- о тяжеловесности интерфейса и реализации, 
- о решении классом не связанных друг с другом задач, 
- о том, что здесь много кода и мало классов, 
- о том, что в коде много лишнего шума, который нужно перенести в отдельные классы, чтобы было легче увидеть его основную суть, 
- о том что высокоуровневая логика перемешана с низкоуровневыми деталями и т.п. 
Иногда я готовлю классы к будущим изменениям, но в плане сопровождаемости, а не в плане нарушения SRP.


- http://sergeyteplyakov.blogspot.com/2014/08/single-responsibility-principle.html
- https://blog.byndyu.ru/2009/10/blog-post.html еще примеры
//todo почитать
- https://habr.com/ru/post/465507/

#### The OpenClosed Principle
Программные сущности должны быть открыты для расширения и закрыты для модификации.

Смысл принципа OCP
 довольно прост: дизайн системы должен быть простым и устойчивым к изменениям.
 Это достигается путем фиксация интерфейса класса/модуля, и возможность изменения или подмены реализации/поведения.

- https://web.archive.org/web/20060822033314/
- http://www.objectmentor.com/resources/articles/ocp.pdf
- https://habr.com/ru/company/tinkoff/blog/472186/ (перевод)
- http://sergeyteplyakov.blogspot.com/2014/08/open-closed-principle.html

Если одно изменение в программе влечет за собой каскад изменений в зависимых модулях, то программа становится хрупкой,
 негибкой, непредсказуемой и непереиспользуемой.  (пример: Ни один модуль, который зависит от публичной переменной класса (либо глобальной переменной), 
 не может быть закрыт о модуля, который может писать в нее.)
Принцип гласит, что надо проектировать модули, которые никогда не меняются.
Когда требования меняются, нужно расширять поведение таких модулей путем добавления нового кода, а не изменением старого, уже работающего кода.
Старый код изменяется только для исправления критических ошибок в нем.

Модули, отвечающие принципу открытости-закрытости, имеют два главных признака:
- Открыты для расширения. Это означает, что поведение модуля может быть расширено. То есть мы можем добавить модулю новое поведение в соответствии с изменившимися требованиями
- Закрыты для изменений (с помощью инкапсуляции). Исходный код такого модуля неприкасаем. В результате расширения поведения сущности не должны вноситься изменения в код, который эту сущность использует.


Стандартный способ расширить поведение модуля — внести в него изменения.
Ключ к решения этих 2х условия - _абстракция_. (
**Абстракция не подразумевает наличие наследования. Абстракция не может существовать без инкапсуляции!**)
Т.е. модулю добавляем зависимость от абстракции (как правило интерфейс, либо абстрактный класс), и таким образом, закрываем модуль от изменений. 
При этом детали реализации будет скрыта от клиентов за счет инкапсуляции, которая позволяет изменять реализацию без изменения интерфейса
Для расширения поведения, добавляем необходимую реализацию абстракции (интерфейса) и передаем ее при вызове. 
(с помощью наследования, что позволяет заменить реализацию, которая не затронет существующих клиентов базового класса.)

2) Расширять нужно не все. Нужно чётко определить точки, где вы дадите расширять вашу программную сущность (нельзя давать менять всё подряд). 
(точки изменения из Protected Variantions в GRASP)
3) Определиться с механизмами, которыми будете расширять программную сущность (в любой непонятной ситуации делай выбор в пользу композиции, см Наследование vs композиция)
Варианты расширения (используя полиморфизм, композицию)
- наследование (если есть открытый для наследования базовый класс либо абстрактный класс.
Клиентский код делаем зависимым от базового класса (либо абстрактного), и для изменения (расширения) поведения клиентского кода, добавляем нового наследника от базового класса и передаем его. При этом клиентский код будет закрыт от изменений за счет того, что зависит от абстрактного класса
	- (-) все связанные минусы с наследованием (сильное сцепления и тп)
Если выбрали наследование, помните о проблеме хрупких базовых классов. Предок должен быть закрыт от наследников настолько, насколько это возможно.

- патерн "стратегия": целевой класс через параметр метода/конструктора принимает объект с логикой, расширяющей поведение этого класса. 
Далее, реализуем необходимое поведение (реализуя интерфейс) и передаем свою реализацию в модуль. Классы при этом закрываем от наследования с помощью final

- следующий вариант: выделение интерфейса всего класса и реализация необходимого поведения (через реализацию интерфейса).
Клиент зависит от интерфейса. Во время выполнения передаем конкретную реализацию
	- (+)  полностью убрали зацепление классов по реализации. В этом случае классы разделяют только сигнатуры методов и полностью отсутствует какое-либо унаследованное поведение. Классы объявлены как final, а значит исключаются все связанные с наследованием реализации проблемы: хрупкость базового класса, запутанность потока выполнения при использовании открытой рекурсии и т.д.
	- (+) явно реализуя интерфейс через отношение implements, мы фиксируем спецификацию (контракт) класса и впоследствии может гибко управлять этим контрактом, например, в соответствии с принципом разделения интерфейсов (ISP). Детали реализации поведения надежно скрыты за интерфейсом и теперь не являются частью контракта, что существенно повышает качество архитектуры приложения.
	- (+) После публикации интерфейса, контракт, который он описывает, закрывается от дальнейшей модификации. А значит и классы, которые реализуют интерфейс через implements, также закрыты от модификации контракта. При этом детали реализации этого контракта остаются открытыми для изменений.
	- (+) Ключевое слово final запрещает наследование, а значит и создание дочерних классов с измененным поведением. Возможна только реализация опубликованного интерфейса. И это существенное преимущество – любое развитие архитектуры не влияет на существующий код, клиенты продолжают взаимодействовать с классом через открытый интерфейс.
Классы в такой архитектуре можно сравнить со «строительными блоками», готовыми к конструированию приложения. С помощью implements мы указываем к какому типу принадлежит блок, а с помощью final делаем класс законченным и готовым к употреблению.
	- (-) они ограничены в отношении наследования. Некоторые реализации могут иметь общий код, который нежелательно копипастить (нарушение DRY).

- (решение минусы выше). (пример https://habr.com/ru/post/482154/) Предпочитаем агрегацию наследованию. Самым слабым типом отношений между классами является агрегация, и она может полноценно заменить наследование. Для этого агрегацию следует применить в форме паттерна декоратор (decorator pattern). И в этом случае мы сохраняем все преимущества классов, как законченных «строительных блоков», – запрет наследования через final и зацепление через интерфейс, реализованный с помощью implements.
	- вводим интерфейс, явно определяющий контракт реализующих его классов
	- реализуем класс, содержащий основную функциональность (что-то вроде базового класса, но в отличии от наследования, закрыт от модификации контракта через implements, и от создания дочерних классов через final)
	- реализуем второй класс как декоратор: принимает в конструкторе декорируемый объект через базовый интерфейс и хранит его в приватном свойстве. Класс вызывает соответствующие методы базового класса и при необходимости дополняет их поведение. (Такие методы называют методами передачи (forwarding methods).
Однако методы передачи могут и не включать никакой дополнительной функциональности, а просто возвращать результат «как есть». При использовании наследования, такие «однострочные» методы не требовалось бы включать в дочерний класс, а поведение было бы автоматически унаследовано из родительского класса, что в некоторой степени сократило бы объем кода.
Некоторые разработчики именно по этой причине отдают предпочтение наследованию, которое сокращает объем кода. Особенно в случае, если при агрегации классы-декораторы большей частью состояли бы из таких «однострочных» методов передачи. Стоит сказать, что написание дополнительной строки кода – довольно невысокая цена за получаемые с агрегацией преимущества (слабое зацепление, следование SOLID) и избегаемые недостатки наследования (нарушение сокрытия, хрупкость архитектуры, зацепление на реализацию).
Агрегация покрывает все возможности наследования. Классы SimpleCommentBlock и CountingCommentBlock реализуют общий интерфейс CommentBlock, а потому могут полиморфно замещаться в коде. Разместив основное поведение в базовом классе и дополнив его в классе-декораторе, мы можем избежать дублирования кода.
Однако, если открытость класса к наследованию подталкивает нас к зацеплению на особенности реализации и повторному использованию кода, то использование модификатора final подталкивает разработчика к выбору механизма агрегации и зацеплению на поведение класса, контракт которого описан в виде интерфейса CommentBlock.

Теперь добавление нового метода viewRandomComment() в базовый класс SimpleCommentBlock никак не влияет на структуру и поведение изолированного класса-декоратора CountingCommentBlock. Если бы использовалось наследование, то метод был бы неявно включен в состав дочернего класса и нарушил логику его работы – в реализации viewRandomComment() не предусмотрен подсчет количества просмотров. Вызовы CountingCommentBlock::viewRandomComment() не учитывали бы просмотры в кеше.
Кроме того, изменение деталей реализации viewComments() в базовом классе SimpleCommentBlock не повлияет на зависящие от него классы. CountingCommentBlock не опирается на реализацию поведения в базовом классе SimpleCommentBlock, он зависит только от контракта.

О том, выделять контракт в отдельный интерфейс или нет.
Для стабильных (stable) зависимостей – не выделяем.
Для изменчивых (volatile) зависимостей – выделяем, ибо  такой класс может иметь несколько возможных реализаций.
Сущности предметной области (вроде Post, Comment) или объекты-значения (value object) являются стабильными (stable) внутренними зависимостями с одной конкретной реализацией. А потому должны в тестах использоваться напрямую (не выделяя интерфейс и не мокая их). Это соответствует стилю classical TDD (а не mockist TDD).
Но допустим, что ваш класс является изменчивой (volatile) зависимостью и может иметь несколько возможных реализаций. В этом случае, нужно понять, что тестовый «двойник» – это всего лишь еще одна, упрощенная фиктивная реализация. А это значит, что тестовый «двойник» не должен наследовать и переопределять поведение оригинального класса, он должен разделять с ним общий интерфейс. И если архитектура системы построена на базе принципа инверсии зависимостей (DIP), а элементы зависят только от абстракций, то тестовый «двойник» сможет полиморфно замещать оригинальный класс без наследования.
Пример 
- про фигуры, круг и квадрат https://habr.com/ru/company/tinkoff/blog/472186/
- https://habr.com/ru/post/446816/
- https://habr.com/ru/post/482154/

#### L - LSP - Liskov Substitution Principle

- Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом. (c) вики (с) Роберт С. Мартин
- Если базовый класс проходит определённый юнит-тест, то его должны проходить все наследники базового класса тоже.
- Должна существовать возможность использовать объекты производного класса вместо объектов базового класса. 
Это значит, что объекты производного класса должны вести себя согласованно, согласно контракту базового класса.

ссылки: 
- http://sergeyteplyakov.blogspot.com/2014/09/liskov-substitution-principle.html Очень хорошое описание
- https://wiki.php.net/rfc/covariant-returns-and-contravariant-parameters
- https://php.watch/articles/php-lsp
- https://www.youtube.com/watch?v=bVwZquRH1Vk
- https://madewithlove.com/liskov-substitution-principle-explained/
- https://dev-gang.ru/article/solid-%C2%ABl%C2%BB-princip-podstanovki-barbary-liskov-zbmdty8bnw/

Почему важно следовать принципу подстановки Лисков?

- «Поскольку в противном случае иерархии наследования приведут к неразберихе. 
Неразбериха будет заключаться в том, что передача в метод экземпляра класса-наследника приведет к странному поведению существующего кода.
- Поскольку в противном случае юнит-тесты базового класса никогда не будут проходить для наследников.»

Основные моменты
- Глвные моменты: Пред и пост условия. Пред условия не могут быть усилены, пост условия не могут быть ослаблены 
    - 1 Pre conditions
     д.б. теми же либо слабее (не могут быть усилены): Контрвариантность принимаемого значения (тот же либо более общий)
    - 2 Post conditions: Ковариантность возвращаемого значение (пост условие)
    - 3 Ковариантность выбрасываемых исключений (пост условие). 
        - Переопределенные методы дочерних классов должны выбрасывать тот же либо более специфичный тип исключений, который может выбрасываться в родительском классе. 
        (The overriden methods in child classes should throw the same or more specialized exceptions that can be thrown in the parent class.)
        - Никакие новые исключения не должны создаваться методами подтипа, за исключением тех случаев, когда сами эти исключения являются подтипами исключений, создаваемых методами супертипа. 
        (No new exceptions should be thrown by methods of the subtype, except where those exceptions are themselves
         subtypes of exceptions thrown by the methods of the supertype).
    - invariants are the same (or stronger)

- (для php) Сигнатуры методов должны совпадать: можно расширить список параметров необязательным аргументов
- (для php) инвариантность типа параметра в наследнике
- (для php) хотя аргументы методов в подтипах всегда должны быть контравариантными, аргументы в методах подтипов __construct
 () не обязательно должны быть контравариантными в php.

альтернативное описание требование в подклассам
- Производные классы не должны усиливать предусловия (не должны требовать большего от своих клиентов).
- Производные классы не должны ослаблять постусловия (должны гарантировать, как минимум тоже, что и базовый класс).
- Производные классы не должны нарушать инварианты базового класса (инварианты базового класса и наследников суммируются)
- Производные классы не должны генерировать исключения, не описанные базовым классом.

Ковариантность - сужение типов (более специфичный тип). Для возвращаемого типа метода в дочернем классе

    class Image {}
     class JpgImage extends Image {}
     
     class Renderer {
          public function render(): Image;
     }
     
     class PhotoRenderer {
         public function render(): JpgImage;
     }
 
 Еще пример (сразу ковариантонсть по возврат типу и контрвариантности по принимаемому аргументу)
 
     class Foo {
         public function process(int|float $value): string|int;
     }
     
     class Bar extends Foo {
         public function process(int|float|string $value): int;
     }


Контрвариантность - расширение типов (более абстрактный тип) в методе наследника. Он должен принять все параметры, которые может принять родитель

Про нарушение в конструкторе

    abstract class CustomFieldDefinition
    {
        public function __construct(AccountId $accountId) { ... }
    }
    
    // Example of a Liskov Substitution Principle violation but allowed by PHP:
    final class MultipleChoiceFieldDefinition extends CustomFieldDefinition
    {
        public function __construct(
            AccountId $accountId,
            array $choices
        ) {
            // By adding an extra required argument, we just broke the method calls 
            // of any code trying to construct instances of CustomFieldDefinition.
        }
    }

So to prevent this from becoming an issue, we closed off the __construct method from being modified by making it final.
    
    abstract class CustomFieldDefinition
    {
        final public function __construct(AccountId $accountId) { ... }
    }
    
Another alternative would be making it private and having a static create(...): CustomFieldDefinition method on CustomFieldDefinition instead.

    abstract class CustomFieldDefinition
    {
        private function __construct(AccountId $accountId) { ... }
    
        public static function create(
            AccountId $accountId, 
        ): CustomFieldDefinition {
            // We can still use the constructor here because we have access to any private
            // methods and properties defined in this class, including __construct().
            return new static($accountId, $variableName);
        }
    }


#### Interface Segregation Principle
- Программные сущности не должны зависеть от частей интерфейса, которые они не используют (и знать о них тоже не должны).
- Клиенты не должны зависеть от методов, которые они не используют.

Есть небольшое сходство с YAGNI - «клиенту могут и не понадобятся эти методы интерфейса»

- http://sergeyteplyakov.blogspot.com/2014/08/interface-segregation-principle.html

Этот принцип относится к недостаткам "жирных" интерфейсов. Говорят, что класс имеет жирный интерфейс, если функции этого 
интерфейса недостаточно сцепленные (not cohesive). Иными словами, интерфейс класса можно разбить на группу методов. Каждая группа 
предназначена для обслуживания разных клиентов. Одним клиентам нужна одна группа методов, другим – другая

Нарушение этого принципа зависит не столько от самого класса, сколько от сценариев его использования.  Если в нашей бизнес-модели
 четко разделяются операции чтения и обновления данных (такой себе CQRS), то наличие одного класса со всеми операциями однозначно 
 делает интерфейс слишком толстым. С другой стороны, если наше приложение напичкано кучей простых форм, которые мапятся 1 к 1 с
  нашими репозиториями, то тогда принцип ISP не нарушается.

 **Отличие принципов SRP и ISP**. Мы хотим следовать SPR, чтобы наш класс был связанным внутри (highly cohesive
 ), что позволит с меньшими усилиями его понимать и развивать. Следование же принципу ISP уменьшает связанность (low coupling)
  между классом и его клиентом, ведь теперь клиент завязан не на весь интерфейс класса, а лишь на его часть.


ISP отличается от других принципов из семейства SOLID тем, что глядя лишь на класс/модуль мы не можем сказать, нарушается принцип ISP или нет.
Нарушение этого принципа зависит не столько от самого класса, сколько от сценариев его использования.
 Если разные клиенты интересуются разными аспектами данного класса/модуля, 
 то выделение дополнительных интерфейсов сделают такое разделение более очевидным.

Если же интерфейс класса «жирный» и непонятный, то класс не просто нарушает ISP, он нарушает SRP и ждет рефакторинга и упрощения.

Существует несколько причин для выделения у класса дополнительных интерфейсов.

- Во-первых, может появиться необходимость выделить интерфейс для класса целиком. Это бывает необходимым для «изменчивых» зависимостей 
(классов, взаимодействующих с внешним миром) или для стратегий (когда нам нужно полиморфное поведение, определенное интерфейсом).

- Во-вторых, мы можем выделить некий аспект текущего класса, который покрывает не весь функционал, а лишь его часть, т.е.
 его отдельный аспект. Примером может служить добавление классу «ролевых» интерфейсов (Role Interface), типа ICloneable, IComparable<T>,
  IEquatable<T> и т.п. При этом выделение таких интерфейсов обычно требуется для использования класса в новом контексте (
  класс Person реализуется IComparable<T> для корректного использования в SortedList).

- В-третьих, может потребоваться выделение специализированных бизнес-интерфейсов, когда станет очевидным, что наш класс используется 
в нескольких разных контекстах. Например, когда репозиторий используется разными клиентами двумя способами: одна группа клиентов использует лишь 
операции для чтения данных, а другая группа – для обновления. Обычно это говорит не столько о нарушении ISP, сколько о наличии 
скрытой абстракции (IRepositoryReader и IRepositoryWriter).

- В-четвертых, нам может потребоваться использовать несколько разных классов из разных иерархий наследования полиморфным образом 
(именно этот пример был показан в предыдущем разделе). При этом обычно такое выделение происходит во время рефакторинга, когда
 необходимость в этом становится очевидной:

«Ага, вот у нас есть два класса, которые мы могли бы использовать совместно, но они уже унаследованы от разных базовых классов.
 Давайте выделим для каждого из них единый интерфейс и избавимся от богомерзких if-else».

#### Dependency Inversion Principle
- Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
- Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

http://sergeyteplyakov.blogspot.com/2014/09/the-dependency-inversion-principle.html

цели принципов: 
- SRP предназначен для борьбы со сложностью; 
- OCP помогает в вопросах расширяемости и параллельной разработки; 
- LSP указывает, как использовать наследование «правильно»;
- ISP выделяет разные аспекты класса; 
- DIP должен бороться с признаками плохого дизайна в архитектуре

признаками плохого дизайном:
- Дизайн является жестким (rigid
), если его тяжело изменить, поскольку любое изменение влияет на слишком большое количество других частей системы.
- Дизайн является хрупким (fragile), если при внесении изменений неожиданно ломаются другие части системы.
- Дизайн является неподвижным (immobile
), если код тяжело использовать повторно в другом приложении, поскольку его слишком сложно «выпутать» из текущего приложения.

Цель: заменить композицию агрегацией. То есть вместо создания зависимостей напрямую, класс должен требовать их у более высокого уровня 
через аргументы метода или конструктора. При этом зависимость должна передаваться не в виде экземпляров конкретных классов, 
а в виде интерфейсов или абстрактных классов.

    interface IDependency
    { }
    class ConcreteDependency : IDependency { }
     
    // ConcreteClass не знает о ConcreteDependency, 
    // он зависит от "абстракции" - IDependency!
    class ConcreteClass
    {
        public ConcreteClass(IDependency dependency)
        {}
    }

Ключевую роль в ослаблении связей между клиентом и сервисом играет принцип инверсии зависимостей (dependency inversion principle, DIP), 
предлагающий преобразовать прямую зависимость между модулями в обоюдную зависимость модулей от общей абстракции.

- Модули высокого уровня (бизнес сущности с высокоуровневыми политиками), не должны зависить от низкоуровневых реализаций,
 библиотек для работы с бд, отправкой писем, очередями и либо других инфраструктурных вещей и фреймворков. А должны зависить от абстракции.
- На этом принципе построенны реализация направления зависимости в "Чистой архитектуре", гексогональной, онион, DDD
. Все зависимости должны направлены в стороны высокоуровневых политик (против поток исполнения).
- Модули высокого уровня определяют абстракцию (интерфейс), и используют ее, а модули нижних уровняй реализую это интерфейсы и
 прокидывают адаптеры на уровни выше (di, парамметры).

- (+) это позволяет писать более чистый и независимый код (от библиотек, фреймворков и прочего)
- (+) улучшает сопровождение
- (+) упрощает тестирование отдельных компонентов. В тестах мы можем не использовать сложные реализации, а заменять их заглушками для простоты.

**Абстракция и реализация**
Давайте рассмотрим вопрос «зависимости от абстракции» более подробно.

Любой класс содержит две части: открытый интерфейс и реализацию. Реализация скрыта от клиентов класса и может в разумных пределах 
изменяться не затрагивая клиентов. Изменение открытой/защищенной части класса влечет за собой изменение клиентов и/или наследников.

Если под «абстрактным интерфейсом» понимать открытую часть класса, то в использовании конкретных классов напрямую нет никакой проблемы.
 Если же под «абстрактным интерфейсом» понимать использование специфических конструкций, типа интерфейсов или абстрактных 
 классов языка C#, то тут нужно понять, что это дает.
 
 **Когда выделять интерфейсы?**
 С практической точки зрения мы знаем, что иногда нам можно и нужно создавать экземпляры конкретного класса напрямую, 
 а иногда стоит выделить у класса интерфейса и передавать уже его.
 
Когда выделять интерфейс (.NET interface) у класса:
- Класс является реализацией некоторой стратегии и будет использовать полиморфным образом.
- Реализация класса работает с внешним окружением (файлами, сокетами, конфигурацией и т.п.). 
Использование напрямую классов, работающих с файлами, сокетами, базой данных и т.п. в бизнес-коде приложения может быть проблематичным.
Значительно лучше выделить более высокоуровневую стратегию (IYourDataProvider
), одна из реализаций которой получает данные из файла/бд, сети и тп
- Класс находится на стыке модулей.

Когда не нужно выделять интерфейс класса:
- Класс является неизменяемым «объектом-значением» (Value Object) или объектом-данных (Data Object).

Нет никакого смысла от выделения интерфейсов для простых классов, особенно для неизменяемых объектов-значений (т.н. Value Objects).
 Неизменяемые объекты-значения – это идеальный механизм борьбы со сложностью: их поведение (если оно есть) простое и абсолютно стабильное.
- Класс обладает стабильным поведением (не работает с внешним окружением).

К _стабильным зависимостям_ относятся классы, поведение которых не зависит от времени: они не работают с внешним окружением и интерфейс 
которых относительно стабилен.
 Поведение _изменчивых зависимостей_ зависит от времени или контекста, или же их интерфейс часто изменяется.
 
Исходя из всего этого можно выделить несколько советов по выделению интерфейсов:
- Выделяйте высокоуровневые стратегии (IMessageProvider, а не IMSMQProvider).
- Старайтесь передавать результаты работы зависимостей, а не сами зависимости (передавайте Configuration (value object
), а не IConfigurationProvider).
- Используйте стандартные абстракции (Stream вместо своего собственного IFileStream, Task вместо IAsyncWorkItem и т.п.)

Принципы управления зависимостями:
- Делайте важные зависимости явными.
- Старайтесь минимизировать число зависимостей (если класс может о чем-то не знать, то избавьте его от этой лишней информации).
- Выделяйте изменчивые зависимости и старайтесь сделать их высокоуровневыми.
- Выделяйте стратегии
- Стремитесь к неизменяемости: объекты-значения (Value Objects
) и функции без побочных эффектов – это идеальный строительный материал.
- Не нужно «инвертировать» зависимости: дизайн – процесс итеративный, модули верхнего уровня влияют на дизайн модулей нижнего уровня и наоборот.

### IoC

todo

### Закон Деметры



### GRASP
Ввел Крейг Ларман в своей книге.
Суть: описание фундаментальнымх принципов распределения ответственности между классами.

GRASP'овские паттерны являются обобщением GoF'овских паттернов, а также непосредственным следствием принципов ООП. 
Они дополняют недостающую ступеньку в логической лестнице, которая позволяет получить GoF'овские паттерны из принципов ООП.
 Шаблоны GRASP являются скорее не паттернами проектирования (как GoF'овские), а фундаментальными принципами распределения ответственности между классами. 
 Они, как показывает практика, не обладают особой популярностью, однако анализ спроектированных классов с использованием 
 полного набора GRASP'овских паттернов является необходимым условием написания хорошего кода.
 GRASP покрывает все аспекты SOLID

Связь различных принципов (разные взгляды на одно и тоже)
- coheasion = imformation expert = factory = srp = encapsulatio
- inderection = dip
- LSP = полиморфизм

Полный список шаблонов GRASP состоит из 9 элементов:

Information Expert
Creator
Controller
Low Coupling
High Cohesion
Polymorphism
Pure Fabrication
Indirection
Protected Variations

- http://blogerator.org/page/oop-patterny-i-principy-grasp
- https://ru.wikipedia.org/wiki/GRASP
- https://habr.com/ru/post/92570/
- https://habr.com/ru/post/38323/

- Polymorphism

#### Information Expert 
**Информация должна обрабатываться там, где она содержится**
(напоминает TellDontAsk от Фаулера)
- https://habr.com/ru/company/otus/blog/491636/ статья с описанием

Описывает основополагающие принципы назначения обязанностей классам и объектам. 
Согласно описанию, информационным экспертом (объектом наделенным некоторыми обязанностями) является объект,
 обладающий максимумом информацией, необходимой для выполнения назначенных обязанностей.
 
 Т.е. если объект владеет всей нужной информацией полностью для какой-то операции или функционала, то значит, 
 что этот объект будет выполнять всё сам, либо получать делегировать выполнение этой операции от других.

+ повышает связность модулей

Итак, рассмотрим пример. Есть некая система продаж. И есть класс Sale (продажа). Нам необходимо посчитать общую сумму продаж. Тогда кто будет считать общую сумму по продажам? Конечно же, класс — Sales , потому что именно он обладает всей информацией необходимой для этого.

#### Creator
**Cоздавать экземпляры класса должен класс, которому они нужны**

- https://habr.com/ru/company/otus/blog/505618/
Creator или Создатель — суть ответственности такого объекта в том, что он создает другие объекты. 
Сразу напрашивается аналогия с фабриками. Так оно и есть. Фабрики тоже имеют именно ответственность — Создатель.

Но есть ряд моментов, которые должны выполняться, когда мы наделяем объект ответственностью создатель:

- Создатель содержит (композит) или агрегирует создаваемые объекты (содержит в себе как свойство или коллекцию)
- Создатель использует создаваемые объекты (основной объем работы с объектом Б происходит посредством объекта А)
- Создатель знает, как проинициализировать создаваемый объект. 
Объект А обладает данными инициализации объекта Б (каждый раз при создании объекта Б, данные берутся из объекта А)
- Создатель записывает создаваемые объекты

Альтернатива - шаблон "Фабрика".


#### Controller
Controller
- это объект, который отвечает за обработку входящих системных событий (пользовательские нажатия кнопок, срабатывания таймеров т.д.), 
и при этом не относится к интерфейсу пользователя. 
Controller определяет методы для выполнения системных операций.

Controller— это объект-прослойка между UI-логикой и предметной (бизнес) логикой приложения. 
Создаем контроллер так, чтобы все вызовы от UI перенаправлялись именно ему и соответственно, все данные UI тоже получает только через него.

Напоминает известные MVC и MVP? Так и есть. Это по сути Presenter из MVP и контроллер из MVC. 

Контроллер отвечает на такой вопрос: «Как UI должен взаимодействовать с доменной логикой приложения?»
Или ещё проще: «Как взаимодействовать с системой?». Это чем-то напоминает фасад дома. Фасад тоже предоставляет облегченный доступ
 к целой подсистеме объектов. Так и тут: контроллер для UI своего рода фасад, который предоставляет доступ к целой подсистеме бизнес-логики.

- Отвечает за операции, запросы на которые приходят от пользователя,
 и может выполнять сценарии одного или нескольких вариантов использования (например, создание и удаление);
- Не выполняет работу самостоятельно, а делегирует компетентным исполнителям;

#### Low Coupling and High Cohesion

- https://habr.com/ru/company/otus/blog/505852/
- https://stackoverflow.com/questions/3085285/difference-between-cohesion-and-coupling
Низкая зацепление (Low Coupling) и Высокое связность (High Cohesion).

`Cистема должна состоять и слабо связанных классов, которые содержать связанную бизнес — логику. `
Соблюдение этих принципов позволяет удобно переиспользовать созданные классы, не теряя понимания об их зоне ответственности.

Их имеет смысл рассматривать только в паре, потому что рассмотрение их по отдельности в пределе приводит к явно плохому коду. 
Эти принципы могут рассматриваться в разных контекстах, при проектировании: методы, классы, модули, слои, микросервисы.

Внутреннюю структуру проекта нужно поддерживать в таком состоянии, которое позволит внести значительные (и не очень) изменения с минимальными переделками.

Рассмотрим понятие меры зацепления модулей и меры связности модуля.
Мера Coupling (зацепление) модулей определяется количеством информации которой располагает один модуль о природе другого. 
В свою очередь, мера cohesion (связности) модуля определяется степенью сфокусированности его обязанностей.

Логика внутри модулей сильно завязана на их внутренее устройство и очень слабо зависит от других модулей.
Реализация каждого модуля внутри уникальна и сокрыта (инкапсулирована) от других.
При этом имеет сильные связи между элементами находящимися внутри модуля, а с элементами других модулей слабые,
Один слой может обращаться ко второму и использовать только небольшую часть его классов.

Плюсы (соответствие данным патернам позволяет):
- легкость модификации и сопровождение модулей (не оказывая существеного влияния на работу других модулей)
- повышает степень повторного использования

Low Coupling (зацепление, сопряжение))
- Необходимо распределить ответственности между классами так, чтобы обеспечить минимальную связанность.
- объекты в системе должны знать друг о другие как можно меньше
- паттерн, который указывает, как назначать ответственность: слабая зависимость между классами,
изменение одного должно иметь минимальные последствия для другого, максимальная возможность повторного использования
- метрика, показывающая, насколько компоненты системы независимы друг от друга. 
Слабо связанные компоненты не зависят от внешних изменений и легко могут быть использованы повторно. 
IoC и DIP являются средствами для достижения слабой связности компонентов в системе.

High Cohesion (связность -  сила)
- классы должны содержать связанную бизнес — логику.
- (по Макконелу, рассматривает только на уровне методов, ибо на уровне классов данный принцип вытесняется более современными концепциями: абстракция, инкапсуляция)
 - характеризует соответствие выполняемых в методе операций единой цели
- предпологает, что класс спланирован с единственным и конкретным назначением
- метрика(принцип), показывающая, насколько хорошо код сгруппирован по функционалу.
 Выполнение принципов DRY и SRP ведет к коду с сильной связностью, в котором части, выполняющие одну и ту же задачу 
 расположены «близко» друг к другу, а разные — изолированы. Выполнение ISP тоже ведет к сильной связности, хотя это и не так очевидно. 
 Разделяя один интерфейс на более мелкие части вы группируете их по функционалу, оставляя в каждом интерфейсе только наиболее связанные между собой методы.

Если возвести Low Coupling в абсолют, то достаточно быстро можно прийти к тому, чтобы разместить всю функциональность в одном единственном классе. 
В таком случае связей не будет вообще, но все при этом понимают, что что-то тут явно не так, 
ведь в этот класс попадет совершенно несвязанная между собой бизнес — логика. 
Принцип High Cohesion говорит нам следующее: классы должны содержать связанную бизнес — логику.

#### Pure Fabrication
Чистая выдумка. суть в выдуманном объекте (этакий хак, без которого не соблюдаются остальные важные принципы).
Аналогом может быть шаблон Service в парадигме DDD.

Иногда, сталкиваемся с таким вопросом: «Какой объект наделить ответственностью, но принципы информационный эксперт, 
высокая сцепленность не выполняются или не подходят?». Тогда нужно использовать синтетический класс который обеспечивает высокую сцепленность. 
Тут без примера точно не разобраться.

Итак — ситуация. Какой класс должен сохранять наш объект Sale в базу данных? Если подчиняется принципу «информационный эксперт», 
то Sale , но наделив его такой ответственностью мы получаем слабую сцепленность внутри него. Тогда можно найти выход, с
оздав синтетическую сущность — SaleDao или SaleRepository , которая будет сильно сцеплена внутри и будет иметь единую ответственность
 — и правильно сохранять Sale в базу.

Так как мы выдумали этот объект, а не спроектировали с предметной области, то и он подчиняется принципу «чистая выдумка».
 
Синтезированный (выдуманный) объект не относится к предметной области, но:
- Уменьшает зацепление;
- Повышает связность;
- Упрощает повторное использование.

«Pure Fabrication» отражает концепцию сервисов в модели DDD
- Пример задачи: Не используя средства класса «А», внести его объекты в базу данных.
- Решение: Создать класс «Б» для записи объектов класса «А» (см. также: «Data Access Object»). 

#### Indirection
Посредник / Перенаправление

Принцип позволяет реализовать низкое зацепление между классами, путем назначения обязанностей по их взаимодействию дополнительному объекту — посреднику.

Плюсы:
- уменьшает зацепление между классами

Примеры:
- паттерн "посредник" из GoF
- Controller из MVC - посредником между данными их их представлением. Ослабляет зацепление между данными (model
) и их представлением (view).

UI-логике на самом деле нужен не контроллер, а модель, доменная логика. Но мы не хотим, чтобы UI
-логика была сильно связанна с моделью, и возможно в UI мы хотим получать данные и работать с разной предметной логикой. 
А связывать UI-слой с бизнес логикой было бы глупо, потому что получим код который будет сложный для изменений и поддержки. 
Выход — вводим контроллер как посредник между View и Model.
- искуственный класс SomeModelRepository (из принципа выше Pure Fabrication
) - является промежуточным слоем между доменными сущностями и хранилищем, в которое их нужно сохранить.

#### Protected Variantions
Устойчивый к изменениям / сокрытие реализации

Проблема модификации системы наиболее актуальна в условиях динамически изменяющихся требований.
Суть принципа: защита элементов системы от изменения других элементов (объектов и подсистем) путем:
- определенеия "точки изменения" - места в системе, которые наиболее часто будут подвержены изменениям и модификации
- устранение "точек изменения" путем выделения/фиксирования их в абстракции (интерфейсе), (только) через интерфейс возможно взаимодействие с другими элементами системы
- поведение может варьироваться лишь через создание другое реализации интерфейса

Все это делается для того лишь, чтобы обеспечить устойчивость интерфейса. 
Если будет много изменений связанных с объектами, он, в таком случае считается неустойчивым, и тогда нужно выносить его в абстракцию

#### Polymorphism
(см в разделе ООП) возможность трактовать однообразно разные объекты с одинаковым интерфейсом.

Полиморфизм решает проблему обработки альтернативных вариантов поведения на основе типа. Яркий пример этого — шаблон из GoF, — Strategy (Стратегия). 
(Chain of Resposibility, Command etc - все основаны на полиморфизме)

------
## СУБД

#### Vertica

Основные положения Vertica 
https://docs.google.com/document/d/1gSRmERjHqVBRIU6OpmvAPWOYBZlGHxsrWg4CXLiq5U0/edit

#### Партицирование

- Партицирование (секционирование) - разделение таблиц (и тд) на отдельные логические части по определенными критериям (с раздельными параметрами физического хранения). В рамках одной ноды.

Используется в целях повышения управляемости, производительности и доступности для больших баз данных.
Возможные критерии разделения данных, используемые при секционировании — по предопределённым диапазонам значений, по спискам значений, при помощи значений хеш-функций; в некоторых случаях используются другие варианты. 
Под композитными (составными) критериями разделения понимают последовательно применённые критерии разных типов.

В отличие от Шардинга (сегментирования), где каждый сегмент управляется отдельным экземпляром СУБД, и используются средства координации между ними (что позволяет распределить базу данных на несколько вычислительных узлов),
при секционировании доступ ко всем секциям осуществляется из единого экземпляра СУБД (или симметрично из любого экземпляра кластерной СУБД, такого, как Oracle RAC).

   - вертикальное партицирование - поколоночно режем большую таблицу
   - горизонтальное - режим построчно в отдельные таблицы (проекции и т.д.) в рамках одной и тойже схемы (сервера, ноды). Если на разных нодах, то это уже шардинг
    

Файл с данными таблицы разрезается по какому-то условию на несколько не больших файлов — партиций.
Для случая с логами разумно партиционировать таблицы по полю, содержащему даты события. 
Часто бывает разумно резать таблицу на partition по году по месяцу или по дням месяца/недели.

#### Шардинг
- Шардинг (Сегментирование) (горизонтальное партиционирование) - разделение (партиционирование) базы данных на отдельные части так,
 чтобы каждую из них можно было вынести на отдельный сервер. Этот процесс зависит от структуры Вашей базы данных и выполняется прямо в приложении в отличие от репликации:
 
    - вертикальный - это выделение таблицы или группы таблиц на отдельный сервер
    
     Берем, допустим, таблицу фото, таблицу юзеров и др., растаскиваем их на отдельные сервера. Если таблицы были большие, то все становится меньше, памяти ест меньше, все хорошо, только нельзя JOIN'ить и приходится делать запросы типа WHERE IN, т.е. сначала выбираем кучу ID'шников, потом все эти ID'шники подставляем запросу, но уже к другому коннекту, к другому серверу.
    
    - горизонтальный - это разделение одной таблицы на разные сервера. Это необходимо использовать для огромных таблиц, которые не умещаются на одном сервере.
    
    например, мы берем и делаем несколько БД с юзерами.
    
    ![Выбор сервера](https://skr.sh/s32A4BAxRlo?a)
    
    Можно достаточно просто выбрать сервер — остаток от деления на количество серверов. Альтернатива — завести карту, т.е. для каждой записи держать в каком-нибудь Redis'е или т.п. ключ значения, т.е. где какая запись лежит.
    
    ![проще](https://skr.sh/s32BB9BAp3K?a)
    
    Сложнее — это когда не удается сгруппировать данные. Надо знать ID данных, чтобы их достать. Никаких JOIN, ORDER и т.д. Фактически мы сводим наш MySQL или PostgreSQL к key-valuе хранилищу, потому что мы с ними ничего делать не можем.
    https://ruhighload.com/Шардинг+и+репликация
    
#### Репликация
- Репликация - полная копия хранимых объектов (таблицы, представления либо все бд)

Обычно делается репликация мастер-слэйв, есть репликация мастер-мастер. Можно делать репликацию вручную, можно делать шардирование и можно делать партицирование.

- https://ruhighload.com/Шардинг+и+репликация
- https://ruhighload.com/Репликация+данных
- https://ruhighload.com/Как+настроить+mysql+master-slave+репликацию%3f
- https://ruhighload.com/Оптимизация+репликации+в+mysql
- https://habr.com/ru/company/otus/blog/491106/ (про sync, async и semisync (полусинхронную_) репликацию)

#### Индексы

- https://habr.com/ru/post/102785/

- low cardinality
 (низкая мощность) - колонка с низким кол-вом уникальных значений, малоуникальная колонка (например, тип или статус), многие строки соответствуют значению ключа
- high cardinality - сильно уникальная колонка (как правило, различные уникальные id)

- https://ruhighload.com/Индексы+в+mysql
 про выбор индексов для запросов, составные индексы, кластерные индексы, explain, селективность 

todo использовать часть кластерного индекса для оптимизации выборки
- обычный индекс - обычно сначала идет проход по фалу индекса, получаем pk
 ключи и по этим первичным ключам лезим на диск (данные по разным pk
  могут находится на разных страницах на диске) 
- кластерный индекс - при поиске по первичному ключу (составному или нет), данные будут доставаться с одних страниц на жестком диске 
(с большой долей вероятности) и осуществится меньшее кол-во дисковых операций (такая оптимизация может сильно увеличить производительность)


### Mysql

- https://www.youtube.com/watch?v=-vu4EbHZ1wY
 - про мониторинг, замер производительности, анализа медленных запросов, внедрение решений
- https://www.youtube.com/watch?v=AscIBgmgeow&feature=emb_logo про индексы в мускуле

#### InoDB vs MyISAM

- MyISAM поддерживает сжатие таблиц в отличии от InnoDB.
- MyISAM имеет встроенные полнотекстный поиск в отличии от InnoDB (InnoDB с 5.6 есть фулл текст индексы)

- InnoDB поддерживает транзакции в отличии от MyISAM.
- InnoDB поддерживает блокировки уровня строки (MyISAM - только уровня таблицы).
- InnoDB поддерживает ограничения внешних ключей (MyISAM - нет).
- InnoDB более надежна при больших объемах данных.
- InnoDB в теории немного быстрее.

- https://ruhighload.com/%D0%A1%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5+innodb+%D0%B8+myisam
- https://ru.stackoverflow.com/questions/58156/%D0%92-%D1%87%D0%B5%D0%BC-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D0%B0-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-innodb-%D0%B8-myisam


_Explain, SHOW STATUS, SHOW PROFILE, slow_log_

- EXPLAIN [FORMAT = JSON]
- SHOW STATUS https://dev.mysql.com/doc/refman/5.7/en/show-status.html
- SHOW PROFILE https://ruhighload.com/%d0%9a%d0%b0%d0%ba+%d0%b8%d1%81%d0%bf%d0%be%d0%bb%d1%8c%d0%b7%d0%be%d0%b2%d0%b0
%d1%82%d1%8c+show+profile+%d0%b2+mysql%3f
про SHOW PROFILE - анализ использования ресурсов запросом

https://habr.com/ru/post/70435/ полезная инфа про show profile

## SQL training

- https://www.hackerrank.com/
- https://sql-academy.org/ (удобный, неплохой)
- https://sqlzoo.net/
- https://sql-ex.ru/learn_exercises.php (один из самых известных в СНГ) + http://www.sql-tutorial.ru/ru/content.html
 с теорией
- https://sqlbolt.com/lesson/ небольшой интерактивный туториал
 
 
- https://www.w3schools.com/sql/sql_examples.asp (список операторов с объяснениями, примерами)
- https://en.wikibooks.org/wiki/SQL_Exercises/The_warehouse примеры sql запросов на таблице хранилище и боксы
- http://sqlfiddle.com/#!9/d5679f/1 удобный составитель запросов (с предварительным create table и insert)

- https://www.internet-technologies.ru/articles/mysql-distinct.html про Distinct  и его сходство с group by 
(distinct + order by = group by)


### Нормализация отношения

Использовать мин 3НФ для обеспечения согласованности данных и отсутствия аномалий.
Если это не проблема, а есть проблема в производительности - то денормализируем.

- https://habr.com/ru/post/254773/
ву- https://office-menu.ru/uroki-sql/51-normalizatsiya-bazy-dannykh
- https://ru.wikipedia.org/wiki/Нормальная_форма#Первая_нормальная_форма_(1NF)

Примеры проектирований бд:
- http://rema44.ru/resurs/study/dbmat/prj2.pdf
- https://publications.hse.ru/mirror/pubs/share/direct/212747315.pdf

## Transaction, ACID, Isolation levels

- https://habr.com/ru/company/mailru/blog/266811/ Как работает РБД

Один из механизмо решения проблем race conditions
 при конкурентном доступе к РБД являются транзакции и уровни их изоляции.

Транза́кция (англ. transaction
) — единая последовательность операций с базой данных, которая представляет собой логическую единицу работы с данными, имея возможность отката и подтверждения операций. 
Транзакция может быть выполнена либо целиком и успешно, соблюдая целостность данных и независимо от параллельно идущих других транзакций, 
либо не выполнена вообще, и тогда она не должна произвести никакого эффекта. Транзакции обрабатываются транзакционными системами, 
в процессе работы которых создаётся история транзакций.

- https://ru.wikipedia.org/wiki/Транзакция_(информатика)

Транзакции - служат для обеспечения доступа к данным в конкурентной среде, тем самым решая проблемы согласованных изменений, и разрешая race condition
 
Также, транзакции обеспечивают сохранность, отказоустойчивости данных (закомиченные данные не теряются)

### ACID - свойства транзакций

 Для полноценного выполнения этих задач транзакция должна обладать свойствами ACID. 
 
- https://habr.com/ru/company/otus/blog/494652/ про acid
- https://ru.wikipedia.org/wiki/ACID
- https://habr.com/ru/post/208400/
- https://habr.com/ru/company/mailru/blog/266811/

Isolation - главное (и самое труднодостегаемое) свойство транзакций. 

### Isolation levels

- https://habr.com/ru/post/469415/ - уровни изолированности в Mysql
- https://ru.wikipedia.org/wiki/Уровень_изолированности_транзакций
- https://en.wikipedia.org/wiki/Isolation_(database_systems)
- https://habr.com/ru/company/otus/blog/501294/ возможные аномалии при ослаблении уровней изоляции
- https://habr.com/ru/post/121858/ про конкурентный доступ к РБД

Алгоритм выбора уровня изоляции:

Сначала надо выбрать минимальный уровень изоляции, который гарантирует корректность поведения в данной транзакции (включая 
корректность данных с одной стороны и отсутствие взаимоблокировок с другой). Замечание про "в данной транзакции" весьма важное.
Обычно это решение достаточно легко следует из того, что вы делаете в транзакции.
Например:
- Вывод списка в грид/на форму — обычно read committed, изредка read uncommitted
 (только в некоторых СУБД имеет смысл, в частности 
в старых версиях MS SQL, или если не используете RCSI)
- Отчёты/формы, состоящие из одного запроса с соединениями/объединениями (join или union) — read committed
- Отчёты/формы, состоящие из нескольких последовательных запросов или использующие временные таблицы — надо оценить, насколько 
тут нужен repeatable read (и действия должны быть в одной транзакции, иначе repeatable read не имеет смысла). Если не нужен, то 
read committed, если нужен, то repeatable read.
- Пишущие транзакции (с проверкой условий/остатков, из нескольких запросов) — используйте по умолчанию не ниже repeatable read.
- В MS SQL
 лучше (с точки зрения корректности данных и отсутствия взаимоблокировок) в пишущей транзакции для тех таблиц, которые меняются 
 в данной транзакции использовать как можно раньше serializable. В других СУБД в зависимости от того, можете ли нарваться на фантомы.

Важно, что всегда сначала выбираем минимальный уровень, обеспечивающий корректную работу, и только потом смотрим, как это можно улучшить.

После того, как определились с базовым уровнем изоляции начинаем смотреть (правильность, производительность одного потока,
 производительность параллельных соединений с сервером, взаимоблокировки и блокировки/race condition горячих мест) и искать компромиссы. 
 Тут уже парой абзацев не отделаться (статья превратится в книгу) — ситуаций и компромиссов даже в одной СУБД, даже типовых 
 быстро становятся десятки. Цикл типичный: сбор информации, гипотеза, проверка, изменение, проверка применимости, внедрение и так по кругу.

### Реализация уровней изоляции и свойства ACID/ (MVCC, locking)

Способы обеспечения изоляции транзакций:
- https://habr.com/ru/company/otus/blog/504190/ MVCC (optimistic СС)- оптимистичный подход
    - https://habr.com/ru/post/208400/ (acid + mvcc в postgress)
- https://habr.com/ru/company/otus/blog/506072/ locking - пессимистичный подход
- комбинированный подход (Частично-оптимистический как в Mysql: блокировки + журнал транзакций + undo log)

- https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html дока mysql

- https://ru.wikipedia.org/wiki/Транзакция_(информатика)
- https://habr.com/ru/company/mailru/blog/266811/ тоже есть про изоляции, блокировки и т.д.
- https://ru.wikipedia.org/wiki/Блокировка_(СУБД)
    -

-----
## REST, SOAP ...

todo


## EventStorming

todo (изучить надосуге)

- https://skillsmatter.com/skillscasts/9507-dddx-bytes
- https://github.com/mariuszgil/awesome-eventstorming
- https://habr.com/ru/company/oleg-bunin/blog/500506/

## Golang

todo начать

- https://tour.golang.org/welcome/1


## Bash

- https://linuxgeeks.ru/bash-intro.htm основы
- https://linuxgeeks.ru/bash-1.htm, https://linuxgeeks.ru/bash-2.htm примеры использования

- jlevy/the-art-of-command-line - The Art of Command Line - 

## Git

- https://githowto.com/ru/thank_you - интерактивный курс для начинающих
- https://habr.com/ru/post/106912/ Удачная модель ветвления для Git
- https://git-scm.com/book/ru/v2 книжка

## Расшифровка некоторых терминов

Авторизация vs аутентификация
https://safe-surf.ru/users-of/article/643444/
- Идентификация — процесс распознавания пользователя по его идентификатору.
- Аутентификация — процедура проверки подлинности, доказательство что пользователь именно тот, за кого себя выдает.
- Авторизация — предоставление определённых прав.

Чуть подробнее
- Идентификация (от латинского identifico
 — отождествлять): присвоение субъектам и объектам идентификатора и / или сравнение идентификатора с перечнем присвоенных идентификаторов. 
 Например, представление человека по имени отчеству - это идентификация.
- Аутентификация (от греческого: αυθεντικός ; реальный или подлинный): подтверждение подлинности чего-либо или кого либо. 
Например, предъявление паспорта - это подтверждение подлинности заявленного имени отчества.
- Авторизация является функцией определения прав доступа к ресурсам и управления этим доступом. Авторизация — это не то же самое 
что идентификация и аутентификация: идентификация — это называние лицом себя системе; аутентификация — это установление 
соответствия лица названному им идентификатору; а авторизация — предоставление этому лицу возможностей в соответствие с 
положенными ему правами или проверка наличия прав при попытке выполнить какое-либо действие. Например, авторизацией являются
 лицензии на осуществление определённой деятельности.


Верификация и валидация

TODO
